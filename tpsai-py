#! /usr/bin/python

from tp.netlib import Connection
from tp.netlib import failed, constants, objects
from tp.netlib.client import url2bits
from tp.client.cache import Cache

version = (0, 0, 1)

import copy
import pprint

import things
Connection.apply = things.apply
from things import *

def distancemap(asset, tasks):
	distances = {}
	for task in tasks:
		distances[dist(asset.ref.pos, task.ref.pos[0])] = task
	return distances

def task_next(asset, distances):
	"""\
	Sort the tasks by the distance between this asset and them.
	"""
	while len(distances) > 0:
		key = min(distances.keys())
		task = distances[key]
		del distances[key]

		# Can we satisfy this task by building something...
		if things.BUILDFLEET_ORDER in asset.ref.order_types:
			soon    = 0
			portion = 100

			# How long is it going to take to "build" this task
			# FIXME: There should be a good way to abstract this...
			if task.type == Task.COLONISE:
				soon += FRIGATE_BUILD
			if task.type == Task.DESTROY:
				soon += BATTLESHIP_BUILD
			if task.type == Task.TAKEOVER:
				soon += BATTLESHIP_BUILD + FRIGATE_BUILD

			# How long will it take for our built object to get to the target?
			if asset.ref.pos != task.ref.pos[0]:
				# How soon we can finish this task is:
				#   build + distance/speed
				d = dist(asset.ref.pos, task.ref.pos[0]) 
				if task.type in (Task.COLONISE, Task.TAKEOVER):
					soon += d/FRIGATE_SPEED
				if task.type == Task.DESTROY:
					soon += d/BATTLESHIP_SPEED

			# Work out the portion of this task we are actually going to build
			if task.type in (Task.DESTROY, Task.TAKEOVER):
				portion = (BATTLESHIP_POWER/(task.power[0]()+MARGIN))*100

			return task, Task.Fulfilment(asset, soon, portion, direct=False)

		# Check we can go where needed for this task
		if asset.ref.pos != task.ref.pos[0]:
			if not things.MOVE_ORDER in asset.ref.order_types:
				continue

		if task.type in (Task.COLONISE,):
			# Only assets which have the colonise order are useful for these tasks
			if not (things.COLONISE_ORDER in asset.ref.order_types):
				continue

			if task.type == Task.COLONISE:
				soon = 0
				if asset.ref.pos != task.ref.pos[0]:
					# Ships always move at the slowest speed...
					soon = dist(asset.ref.pos, task.ref.pos[0])/FRIGATE_SPEED

				return task, Task.Fulfilment(asset, soon, 100)

		if task.type in (Task.DESTROY, Task.TAKEOVER):
			# If this asset has no power, do nothing...
			if asset.power() == 0:
				continue

			# FIXME: This won't work when we merge the Threats
			soon    = 0
			portion = (asset.power()/(task.ref.power()+MARGIN))*100

			if asset.ref.pos != task.ref.pos[0]:
				soon = dist(asset.ref.pos, task.ref.pos[0])/BATTLESHIP_SPEED

			return task, Task.Fulfilment(asset, soon, portion, totally=(things.COLONISE_ORDER in asset.ref.order_types))

def tasks_assign(assets, tasks):
	"""
	Assigns assets to each task.
	"""
	distances = {}
	for asset in assets:
		distances[asset] = distancemap(asset, tasks)
	assets = copy.copy(assets)

	taken = set()
	while len(assets) > 0:
		asset = assets.pop(0)
		print
		print
		print "Assigning task for ", asset

		possible = None
		while True:
			possible = task_next(asset, distances[asset])
			if possible is None:
				break

			task, fulfilment = possible

			# Can we complete this task sooner?
			# Or does this task need help to be completed...
			if task.long() > fulfilment.soon or task.portion() < 100:
				unassigned = task.assign(fulfilment)
			
				print "Assigned to", task, "will complete %.2f%% in %.2f turns" % (fulfilment.portion, fulfilment.soon)
				taken.add(task)

				# Reschedual assignment of assets which are now released...
				print "Took over from %r" % unassigned
				for asset in unassigned:
					assets.insert(0, asset)

				break
	
		# Nothing for me to do
		if possible is None:
			print "Nothing.."
			continue

	return list(taken)

def connect():
	debug = False

	import sys
	print sys.argv

	if len(sys.argv) > 1:
		uri = sys.argv.pop(1)
	else:
		uri = 'tp://tpsai-py:cannonfodder@localhost/tp'

	host, username, game, password = url2bits(uri)
	if not game is None:
		username = "%s@%s" % (username, game)

	connection = Connection()

	# Download the entire universe
	if connection.setup(host=host, debug=False):
		print "Unable to connect to the host."
		return

	if failed(connection.connect("tpsai-py/%i.%i.%i" % version)):
		print "Unable to connect to the host."
		return

	if failed(connection.login(username, password)):
		# Try creating the user..
		print "User did not exist, trying to create user."
		if failed(connection.account(username, password, "", "tpsai-py bot")):
			print "Username / Password incorrect."
			return

		if failed(connection.login(username, password)):
			print "Created username, but still couldn't login :/"
			return

	cache = Cache(Cache.key(host, username))
	return connection, cache

def run(connection, cache):
	# Create the cache
	def callback(*args, **kw):
		#print args, kw
		pass

	cache.update(connection, callback)


	# FIXME: Must be a better way to do this..
	things.cache      = cache
	things.connection = connection
	for id, orderdesc in objects.OrderDescs().items():
		print id, orderdesc
		s = "%s_ORDER" % orderdesc._name.replace(' ', '').upper()
		if not hasattr(things, s):
			print "Unknown order", orderdesc
		else:
			setattr(things, s, id)

	pid = cache.players[0].id
	print "My ID is ", pid

	neutrals = []
	assets = []
	threats = []

	# Classify each object as an Asset/Threat or Neutral and sort on the magnitude
	for object in cache.objects.values():
		if hasattr(object, 'owner'):
			if object.owner in (0, -1):
				neutrals.append(Neutral([object]))
			elif object.owner == pid:
				assets.append(Asset([object]))
			else:
				# Check this object isn't at the same location as another object...
				combined = False
				for threat in threats:
					if object.pos == threat.pos[0]:
						threat.refs.append(object)
						combined = True
						break

				if not combined:
					threats.append(Threat([object]))

	for threat in threats:
		print threat

	# Now we need to collect all threats 
	#  - All threats in a single location are merge
	#  - All threats have a reenforment factor added (dependent on other threats)

	# Now create a list of tasks which need to be done.
	tasks = []
	
	# For each threat, we need to eliminate it or take it over
	for threat in threats:
		if PLANET_TYPE in threat._subtype:
			tasks.append(Task.TAKEOVER(threat))
		else:
			tasks.append(Task.DESTROY(threat))

	# For each neutral we want to colonise the planets
	for neutral in neutrals:
		if not neutral.ref._subtype is PLANET_TYPE:
			continue
		tasks.append(Task.COLONISE(neutral))

	print "\nStep 1. Assigning tasks to assets.."
	print "------------------------------------------------------------------"
	taken = tasks_assign(assets, tasks)

	# Set all the orders so the tasks are performed
	print "\nStep 2. Issuing orders to do tasks.."
	print "------------------------------------------------------------------"
	used_assets = []
	for task in taken:
		print task
		print 
		used_assets += task.issue()
		print "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		print

	print "\nStep 3. Doing some sanity checks..."
	print "------------------------------------------------------------------"
	if len(assets) != len(used_assets):
		print "Some assets don't have tasks!"
		print " %i used assets, %s total assets" % (len(used_assets), len(assets))

		s1 = set([x.ref.id for x in assets])
		s2 = set([x.ref.id for x in used_assets])

		if len(s2) != len(used_assets):
			print "WARNING: For some reason issued orders twice to an object..."

		for id in s1.difference(s2):
			o = cache.objects[id]
			print '\t', Asset([o]).__str__(True)

import time
def persisence():
	connection, cache = connect()

	while True:
		connection.pump()

		pending = connection.buffered['frames-async']
		if len(pending) > 0:
			while len(pending) > 0:
				frame = pending.pop(0)
				if isinstance(frame, objects.TimeRemaining):
					if frame.time == 0:
						continue
					try: 
						run(connection, cache)
					except Exception, e:
						print "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
						print "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
						import traceback
						traceback.print_exc()
						print "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
						print "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"

						import os
						print sys.argv
						#os.execl(__file__, *sys.argv)
						sys.exit(1)

		else:	
			time.sleep(0.1)	

def main():
	run(*connect())

def main_try():
	try:
		run(*connect())
	except Exception, e:
		print e

if __name__ == "__main__":
	import sys
	if len(sys.argv) > 1 and sys.argv[1] == '-p':
		sys.argv.pop(1)
		import hotshot
		prof = hotshot.Profile("hotshot_stats")
		prof.runcall(main)
		prof.close()
	if len(sys.argv) > 1 and sys.argv[1] == '-s':
		sys.argv.pop(1)
		main()
	else:
		persisence()

