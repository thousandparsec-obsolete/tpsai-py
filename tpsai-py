#! /usr/bin/python

from tp.netlib import Connection, failed, constants, objects
from tp.client.cache import Cache

version = (0, 0, 1)

class Reference:
	"""\
	Something which refers to something else.
	"""
	def __init__(self, ref):
		self.ref = ref

	def __str__(self):
		return "<%s ref=%r>" % (self.__class__, self.ref)
	__repr__ = __str__

class Asset(Reference):
	"""\
	An asset is anything which has value to the computer.
	"""

	def power(self):
		"""\
		Returns how powerful an object is.
		"""
		# A Planet is always has no power
		# A fleet is as powerful as the sum of it parts

class Threat(Reference):
	"""\
	A threat is anything which could possibly hurt the computer.
	"""

	def threat(self):
		"""\
		This function returns two values.

		The first value is how threatening the object is in "absolute" terms.
		The second value is how soon this threat must be delt with.
		"""
		# Planets are more threatening but can be dealt with over a longer period of time
		# Ships are less threatening but are more urgent
		#	Unarmed ships are ignored
		#   Big groups of ships are more important
		# Threats which are closer to assets are more threatening
		pass
	
	def power(self):
		"""\
		Returns how powerful an object is.
		"""
		# A planet is equal to x plus a fudge factor
		# A fleet is equal to the sum of its parts
		#   plus a "reinforment factor" of other close by threats
	
class Neutral(Asset, Threat):
	"""\
	A Neutral object is anything which could possibly be an asset or a threat to the computer.
	"""
	pass

def run():
	debug = False
	host = 'tp://localhost'
	username = "mithro@tp"
	password = "me"
	
	connection = Connection()

	# Download the entire universe
	if connection.setup(host=host, debug=debug):
		print "Unable to connect to the host."
		return
			
	if failed(connection.connect("tpsai-py/%i.%i.%i" % version)):
		print "Unable to connect to the host."
		return

	if failed(connection.login(username, password)):
		print "Username / Password incorrect."
		return
		
	# Create the cache
	def callback(*args, **kw):
		print args, kw
	
	cache = Cache(Cache.key(host, username))
	cache.update(connection, callback)

	pid = cache.players[0].id
	print "My ID is ", pid

	neutrals = []
	assets = []
	threats = []

	# Classify each object as an Asset/Threat or Neutral and sort on the magnitude
	for object in cache.objects.values():
		if hasattr(object, 'owner'):
			if object.owner in (0, -1):
				neutrals.append(Neutral(object))
			elif object.owner == pid:
				assets.append(Asset(object))
			else:
				threats.append(Threat(object))

	import pprint
	pprint.pprint(neutrals)
	pprint.pprint(assets)
	pprint.pprint(threats)

	map = {}

	# Figure out which Assets can be used to eliminate Threats (e)
	for asset in assets:
		map[asset] = []
		for threat in threats:
			if threat.power() < asset.power():
				map[asset].append(threat)

	# Figure out which Assets can be used to acquire Neutral (a)

	# Figure out which Assets can be used to produce more Assets (p)

	# Figure out which combinations of (e, a, p) are possible and how long it will take to complete each combination

	# Calculate the top x outcomes of doing the combinations
	
	# Impliment combination where the outcome is the most posative


if __name__ == "__main__":
	run()

