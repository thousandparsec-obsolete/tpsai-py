#! /usr/bin/python

from tp.netlib import Connection
from tp.netlib import failed, constants, objects
from tp.netlib.client import url2bits
from tp.client.cache import Cache

version = (0, 0, 1)

import copy
import math
import pprint

def dist(a, b):
	a = a.ref.pos
	b = b.ref.pos

	return math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2)

from things import *

PLANET_TYPE = 3
MOVE_ORDER = 1
BUILD_ORDER = 2
COLONISE_ORDER = 3

def tasks_cando(assets, tasks):
	"""\
	Figures out which tasks each asset can do.
	"""
	map = {}
	for asset in assets:
		map[asset] = []

		# Figure out which tasks we can do
		for task in tasks:
			# Check we can go where needed for this task
			if hasattr(task.ref.ref, "pos") and asset.ref.pos != task.ref.ref.pos:
				if not MOVE_ORDER in asset.ref.order_types:
					continue

			if task.task in (Task.COLONISE, Task.TAKEOVER):
				# Only assets which have the colonise order are useful for these tasks
				if not COLONISE_ORDER in asset.ref.order_types:
					continue

				if task.task == Task.COLONISE:
					if asset.ref.pos != task.ref.ref.pos:
						priority = 100/dist(asset, task.ref)
					else:
						priority = 100
					map[asset].append((priority, task))

			if task.task in (Task.DESTROY, Task.TAKEOVER):
				# FIXME: This won't work when we merge the Threats
				if task.ref.power() <= asset.power():
					if asset.ref.pos != task.ref.ref.pos:
						priority = task.ref.power()/dist(asset, task.ref)
					else:
						priority = 100
					map[asset].append((priority, task))

			if task.task == Task.BUILD:
				if not BUILD_ORDER in asset.ref.order_types:
					continue

				# The closer we are to the target, the more we want to build this
				if asset.ref.pos != task.ref.ref.ref.pos:
					priority = 100/dist(asset, task.ref.ref)
				else:
					priority = 100
				map[asset].append((priority, task))

	return map

PRIORITY = 0
TASK 	 = 1
BY 		 = 1
def tasks_assign(assets, map):
	"""
	Assigns assets to each task.
	"""
	assets = copy.copy(assets)

	taken = []
	while len(assets) > 0:
		asset = assets.pop(0)
		print "Assigning task for ", asset,

		todo = map[asset]
		todo.sort()

		# Find the first task which is isn't taken by something with a higher priority.
		while len(todo) > 0 and todo[-1][TASK].taken[PRIORITY] > todo[-1][PRIORITY]:
			# Remove this task as somebody else can do it better
			todo.pop(-1)


		# Nothing for me to do
		if len(todo) == 0:
			continue

		print todo[-1]
		priority, task = todo[-1]

		# Is this task assigned to another asset?
		if task.taken[BY] != None and task.taken[BY] != asset:
			# Put the asset back in the queue as we will take this task
			assets.append(task.taken[BY])

		taken.append(task)
		task.taken = (priority, asset)

	return taken

def run():
	debug = False

	import sys
	print sys.argv

	if len(sys.argv) > 1:
		uri = sys.argv.pop(1)
	else:
		uri = 'tp://tpsai-py:cannonfodder@localhost/'

	host, username, game, password = url2bits(uri)

	connection = Connection()

	# Download the entire universe
	if connection.setup(host=host, debug=False):
		print "Unable to connect to the host."
		return

	if failed(connection.connect("tpsai-py/%i.%i.%i" % version)):
		print "Unable to connect to the host."
		return

	if failed(connection.login(username, password)):
		print "Username / Password incorrect."
		return

	# Create the cache
	def callback(*args, **kw):
		print args, kw

	cache = Cache(Cache.key(host, username))
	cache.update(connection, callback)

	pid = cache.players[0].id
	print "My ID is ", pid

	neutrals = []
	assets = []
	threats = []

	# Classify each object as an Asset/Threat or Neutral and sort on the magnitude
	for object in cache.objects.values():
		if hasattr(object, 'owner'):
			if object.owner in (0, -1):
				neutrals.append(Neutral(object))
			elif object.owner == pid:
				assets.append(Asset(object))
			else:
				threats.append(Threat(object))

	# Now we need to collect all threats 
	#  - All threats in a single location are merge
	#  - All threats have a reenforment factor added (dependent on other threats)

	# Now create a list of tasks which need to be done.
	tasks = []
	
	# For each threat, we need to eliminate it or take it over
	for threat in threats:
		if PLANET_TYPE in threat.subtype:
			tasks.append(Task(Task.TAKEOVER, threat))
		else:
			tasks.append(Task(Task.DESTROY, threat))

	# For each neutral we want to colonise the planets
	for neutral in neutrals:
		if not neutral.ref.otype is PLANET_TYPE:
			continue
		tasks.append(Task(Task.COLONISE, neutral))

	print "------------------------------------------------------"
	print "Tasks I have to do..."
	pprint.pprint(tasks)
	print "------------------------------------------------------"

	print "\nStep 1. Finding which assets can do the tasks.."
	print "------------------------------------------------------------------"
	map = tasks_cando(assets, tasks)
	print "\nStep 2. Assigning tasks to assets.."
	print "------------------------------------------------------------------"
	tasks_assign(assets, map)

	# Now are there tasks we can do by building things
	print "\nStep 3. Figuring out what we should build.."
	print "------------------------------------------------------------------"
	for task in copy.copy(tasks):
		# This task is already satisified
		if task.taken[BY] != None:
			continue

		if task.task != Task.BUILD:
			tasks.append(Task(Task.BUILD, task))
			tasks.remove(task)

	print "\nStep 4. Finding out which assets can do the tasks.."
	print "------------------------------------------------------------------"
	map = tasks_cando(assets, tasks)
	print "\nStep 5. Assigning assets.."
	print "------------------------------------------------------------------"
	tasks_assign(assets, map)

	# All tasks which can be done should be assigned now..	
	pprint.pprint(tasks)

	# Set all the orders so the tasks are performed
	print "\nStep 6. Issuing orders to do tasks.."
	print "------------------------------------------------------------------"
	for task in tasks:
		if task.taken[BY] == None:
			continue

		asset = task.taken[BY]

		# Remove any outstanding orders
		if asset.ref.order_number > 0:
			connection.remove_orders(asset.ref.id, range(0, asset.ref.order_number)) 

		# Issue the new order
		if task.task in (Task.COLONISE, Task.DESTROY, Task.TAKEOVER):
			desire = task.ref

			# Are we at the same location?
			if asset.ref.pos != desire.ref.pos:
				print "Issuing orders to %s move %s" % (asset, desire.ref.pos),
				# We need to issue a move order instead.
				connection.insert_order(asset.ref.id, -1, MOVE_ORDER, desire.ref.pos)

			# If it's a colonise order, we better colonise the thing
			elif task.task in (Task.COLONISE, Task.TAKEOVER):
				print "Issuing orders to %s colonise %r" % (asset, desire.ref),
				connection.insert_order(asset.ref.id, -1, COLONISE_ORDER, desire.ref.id)

		if task.task == Task.BUILD:
			if task.ref.task == Task.COLONISE:
				# If we are referencing a colonise, better build a frigate
				print "Issuing orders to %s to build a frigate" % (asset,),
				connection.insert_order(asset.ref.id, -1, BUILD_ORDER, [], [(2,1)], 0, "A robot army!")
			if task.ref.task == Task.DESTROY:
				# Better build a battleship
				print "Issuing orders to %s to build a battleship" % (asset,),
				connection.insert_order(asset.ref.id, -1, BUILD_ORDER, [], [(3,1)], 0, "A robot army!")
			if task.ref.task == Task.TAKEOVER:
				# Better build a battleship and a frigate
				print "Issuing orders to %s to build a battleship and frigate" % (asset,),
				connection.insert_order(asset.ref.id, -1, BUILD_ORDER, [], [(2,1), (3,1)], 0, "A robot army!")

		# Order should complete in
		result = connection.get_orders(asset.ref.id, 0)[0]
		if not result:
			raise IOError("Wasn't able to issue an order for some reason!")
		print "(will complete in %s turns)" % result.turns

if __name__ == "__main__":
	run()

