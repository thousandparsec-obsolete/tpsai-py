#! /usr/bin/python

from tp.netlib import Connection, failed, constants, objects
from tp.client.cache import Cache

version = (0, 0, 1)

import math

def dist(a, b):
	a = a.ref.pos
	b = b.ref.pos

	return math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2)

class Reference:
	"""\
	Something which refers to something else.
	"""
	def __init__(self, ref):
		self.ref = ref

	def __str__(self):
		return "<%s ref=%r>" % (self.__class__, self.ref)
	__repr__ = __str__

class Asset(Reference):
	"""\
	An asset is anything which has value to the computer.
	"""

	def power(self):
		"""\
		Returns how powerful an object is.
		"""
		# A Planet is always has no power
		# A fleet is as powerful as the sum of it parts
		return 10

class Threat(Reference):
	"""\
	A threat is anything which could possibly hurt the computer.
	"""

	def threat(self):
		"""\
		This function returns two values.

		The first value is how threatening the object is in "absolute" terms.
		The second value is how soon this threat must be delt with.
		"""
		# Planets are more threatening but can be dealt with over a longer period of time
		# Ships are less threatening but are more urgent
		#	Unarmed ships are ignored
		#   Big groups of ships are more important
		# Threats which are closer to assets are more threatening
		pass
	
	def power(self):
		"""\
		Returns how powerful an object is.
		"""
		# A planet is equal to x plus a fudge factor
		# A fleet is equal to the sum of its parts
		#   plus a "reinforment factor" of other close by threats
		return 10
	
class Neutral(Asset, Threat):
	"""\
	A Neutral object is anything which could possibly be an asset or a threat to the computer.
	"""
	pass

def run():
	debug = False

	import sys
	print sys.argv

	if len(sys.argv) > 1:
		host = sys.argv.pop(1)
	else:
		host = 'tp://localhost'
	if len(sys.argv) > 1:
		username = sys.argv.pop(1)
	else:
		username = "mithro@tp"
	if len(sys.argv) > 1:
		password = sys.argv.pop(1)
	else:
		password = "me"
	
	connection = Connection()

	# Download the entire universe
	if connection.setup(host=host, debug=debug):
		print "Unable to connect to the host."
		return
			
	if failed(connection.connect("tpsai-py/%i.%i.%i" % version)):
		print "Unable to connect to the host."
		return

	if failed(connection.login(username, password)):
		print "Username / Password incorrect."
		return
		
	# Create the cache
	def callback(*args, **kw):
		print args, kw
	
	cache = Cache(Cache.key(host, username))
	cache.update(connection, callback)

	pid = cache.players[0].id
	print "My ID is ", pid

	neutrals = []
	assets = []
	threats = []

	# Classify each object as an Asset/Threat or Neutral and sort on the magnitude
	for object in cache.objects.values():
		if hasattr(object, 'owner'):
			if object.owner in (0, -1):
				neutrals.append(Neutral(object))
			elif object.owner == pid:
				assets.append(Asset(object))
			else:
				threats.append(Threat(object))

	import pprint
	pprint.pprint(neutrals)
	pprint.pprint(assets)
	pprint.pprint(threats)

	map = {}

	# Figure out which Assets can be used to eliminate Threats (e)
	for asset in assets:
		map[asset] = []
		for threat in threats:
			if threat.power() < asset.power():
				priority = threat.power()/dist(asset, threat)

				map[asset].append((priority, "Attack", threat))

	# Figure out how if Threats can be elimited by merging Assets
	for threat in threats:
		pass

	# Figure out which Assets can be used to acquire Neutral (a)
	for asset in assets:
		# Only assets which have the colonise order are useful for acquring Neutral
		if not 5 in asset.ref.order_types: # FIXME: Shouldn't use a number
			continue
		for neutral in neutrals:
			# Only able to colonise planets
			if not neutral.ref.otype is 3: # FIXME: Shouldn't use a number
				continue

			priority = 100/dist(asset, neutral)
			map[asset].append((priority, "Colonise", neutral))

	# Figure out which Assets can be used to produce more Assets (p)
	for asset in assets:
		# Only assets which have the build order are useful for creating new Assets
		if not 2 in asset.ref.order_types: # FIXME: Shouldn't use a number
			continue

		# Figure out what we should be building
		# if our assets >= their assets build colonise ships
		# otherwise build 

		map[asset].append((10, "Build"))

	pprint.pprint(map)

	# Figure out which is the best deal
	for asset, todo in map.iteritems():
		# Calculate the priority for each item
		todo.sort()

	pprint.pprint(map)

	# Figure out which combinations of (e, a, p) are possible and how long it will take to complete each combination
	# Impliment combination where the outcome is the most posative


if __name__ == "__main__":
	run()

