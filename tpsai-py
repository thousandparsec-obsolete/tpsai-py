#! /usr/bin/python

from tp.netlib import Connection, failed, constants
from tp.client.cache import Cache

version = (0, 0, 1)

class Reference:
	"""\
	Something which refers to something else.
	"""
	def __init__(self, ref):
		self.ref = ref

	def __str__(self):
		return "<%s ref=%r>" % (self.__class__, self.ref)
	__repr__ = __str__

class Asset(Reference):
	"""\
	An asset is anything which has value to the computer.
	"""
	pass

class Threat(Reference):
	"""\
	A threat is anything which could possibly hurt the computer.
	"""
	pass

class Neutral(Asset, Threat):
	"""\
	A Neutral object is anything which could possibly be an asset or a threat to the computer.
	"""
	pass

def run():
	debug = False
	host = 'tp://localhost'
	username = "mithro@tp"
	password = "me"
	
	connection = Connection()

	# Download the entire universe
	if connection.setup(host=host, debug=debug):
		print "Unable to connect to the host."
		return
			
	if failed(connection.connect("tpsai-py/%i.%i.%i" % version)):
		print "Unable to connect to the host."
		return

	if failed(connection.login(username, password)):
		print "Username / Password incorrect."
		return
		
	# Create the cache
	def callback(*args, **kw):
		print args, kw
	
	cache = Cache(Cache.key(host, username))
	cache.update(connection, callback)

	pid = cache.players[0].id
	print "My ID is ", pid

	neutral = []
	asset = []
	threats = []

	# Classify each object as an Asset/Threat or Neutral and sort on the magnitude
	for object in cache.objects.values():
		if hasattr(object, 'owner'):
			if object.owner in (0, -1):
				neutral.append(Neutral(object))
			elif object.owner == pid:
				asset.append(Asset(object))
			else:
				threats.append(Threat(object))

	import pprint
	pprint.pprint(neutral)
	pprint.pprint(asset)
	pprint.pprint(threats)

	# Figure out which Assets can be used to eliminate Threats (e)

	# Figure out which Assets can be used to acquire Neutral (a)

	# Figure out which Assets can be used to produce more Assets (p)

	# Figure out which combinations of (e, a, p) are possible and how long it will take to complete each combination

	# Calculate the top x outcomes of doing the combinations
	
	# Impliment combination where the outcome is the most posative


if __name__ == "__main__":
	run()

