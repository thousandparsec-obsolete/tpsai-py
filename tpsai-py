#! /usr/bin/python

from tp.netlib import Connection
from tp.netlib import failed, constants, objects
from tp.netlib.client import url2bits
from tp.client.cache import Cache

version = (0, 0, 1)

import copy
import math
import pprint

def dist(a, b):
	a = a.ref.pos
	b = b.ref.pos

	return math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2)

import things
from things import *

def tasks_cando(assets, tasks):
	"""\
	Figures out which tasks each asset can do.
	"""
	map = {}
	for asset in assets:
		map[asset] = []

		# Figure out which tasks we can do
		for task in tasks:

			# Can we satisfy this task by building something...
			if BUILD_ORDER in asset.ref.order_types:
				soon    = 0
				portion = 100

				# How long is it going to take to "build" this task
				# FIXME: There should be a good way to abstract this...
				if task.type == Task.COLONISE:
					soon += FRIGATE_BUILD
				if task.type == Task.DESTROY:
					soon += BATTLESHIP_BUILD
				if task.type == Task.TAKEOVER:
					soon += BATTLESHIP_BUILD + FRIGATE_BUILD

				# How long will it take for our built object to get to the target?
				if asset.ref.pos != task.ref.ref.pos:
					# How soon we can finish this task is:
					#   build + distance/speed
					d = dist(asset, task.ref) 
					if task.type in (Task.COLONISE, Task.TAKEOVER):
						soon += d/FRIGATE_SPEED
					if task.type == Task.DESTROY:
						soon += d/BATTLESHIP_SPEED

				# Work out the portion of this task we are actually going to build
				if task.ref.task in (Task.DESTROY, Task.TAKEOVER):
					portion = (task.ref.ref.power()+MARGIN)/BATTLESHIP_POWER

				map[asset].append((soon, task, portion, False))
				continue

			# Check we can go where needed for this task
			if hasattr(task.ref.ref, "pos") and asset.ref.pos != task.ref.ref.pos:
				if not MOVE_ORDER in asset.ref.order_types:
					continue

			if task.type in (Task.COLONISE, Task.TAKEOVER):
				# Only assets which have the colonise order are useful for these tasks
				if not (COLONISE_ORDER in asset.ref.order_types):
					continue

				if task.type == Task.COLONISE:
					soon = 0

					if asset.ref.pos != task.ref.ref.pos:
						# Ships always move at the slowest speed...
						soon += dist(asset, task.ref)/FRIGATE_SPEED

					map[asset].append((soon, task, 100, True))

			if task.type in (Task.DESTROY, Task.TAKEOVER):
				# If this asset has no power, do nothing...
				if asset.power() == 0:
					continue

				# FIXME: This won't work when we merge the Threats
				soon    = 0
				portion = (asset.power()/(task.ref.power()+MARGIN))*100

				if asset.ref.pos != task.ref.ref.pos:
					soon = dist(asset, task.ref)/BATTLESHIP_SPEED

				map[asset].append((soon, task, portion, True))

	return map

def tasks_assign(assets, map):
	"""
	Assigns assets to each task.
	"""
	assets = copy.copy(assets)

	taken = set()
	while len(assets) > 0:
		asset = assets.pop(0)

		print
		print
		print "Assigning task for ", asset

		todo = copy.copy(map[asset])
		todo.sort()

		# The tasks we can complete soonest are first in the todo list now..
		while len(todo) > 0:
			soon, task, portion, direct = todo.pop(0)

			# Can we complete this task sooner?
			# Or does this task need help to be completed...
			print task
			print soon, task.long()

			if task.long() > soon or task.portion() < 100:
				unassigned = task.assign(soon, asset, portion, direct)
			
				print "Assigned to", task, "will complete %.2f%% in %.2f turns" % (portion, soon)
				taken.add(task)

				# Reschedual assignment of assets which are now released...
				print "Took over from %r" % unassigned
				for soon, asset, portion, direct in unassigned:
					assets.insert(0, asset)

				break
	
		# Nothing for me to do
		if len(todo) == 0:
			print "Nothing.."
			continue

	return list(taken)

def connect():
	debug = False

	import sys
	print sys.argv

	if len(sys.argv) > 1:
		uri = sys.argv.pop(1)
	else:
		uri = 'tp://tpsai-py:cannonfodder@localhost/'

	host, username, game, password = url2bits(uri)

	connection = Connection()

	# Download the entire universe
	if connection.setup(host=host, debug=False):
		print "Unable to connect to the host."
		return

	if failed(connection.connect("tpsai-py/%i.%i.%i" % version)):
		print "Unable to connect to the host."
		return

	if failed(connection.login(username, password)):
		# Try creating the user..
		print "User did not exist, trying to create user."
		if failed(connection.account(username, password, "", "tpsai-py bot")):
			print "Username / Password incorrect."
			return

		if failed(connection.login(username, password)):
			print "Created username, but still couldn't login :/"
			return

	cache = Cache(Cache.key(host, username))
	return connection, cache

def run(connection, cache):
	# Create the cache
	def callback(*args, **kw):
		#print args, kw
		pass

	cache.update(connection, callback)
	# FIXME: Must be a better way to do this..
	things.cache      = cache
	things.connection = connection

	pid = cache.players[0].id
	print "My ID is ", pid

	neutrals = []
	assets = []
	threats = []

	# Classify each object as an Asset/Threat or Neutral and sort on the magnitude
	for object in cache.objects.values():
		if hasattr(object, 'owner'):
			if object.owner in (0, -1):
				neutrals.append(Neutral(object))
			elif object.owner == pid:
				assets.append(Asset(object))
			else:
				threats.append(Threat(object))

	# Now we need to collect all threats 
	#  - All threats in a single location are merge
	#  - All threats have a reenforment factor added (dependent on other threats)

	# Now create a list of tasks which need to be done.
	tasks = []
	
	# For each threat, we need to eliminate it or take it over
	for threat in threats:
		print threat, threat.power()
		if PLANET_TYPE in threat._subtype:
			tasks.append(Task.TAKEOVER(threat))
		else:
			tasks.append(Task.DESTROY(threat))

	# For each neutral we want to colonise the planets
	for neutral in neutrals:
		if not neutral.ref._subtype is PLANET_TYPE:
			continue
		tasks.append(Task.COLONISE(neutral))

	print "\nStep 1. Finding which assets can do the tasks.."
	print "------------------------------------------------------------------"
	map = tasks_cando(assets, tasks)

	print "\nStep 2. Assigning tasks to assets.."
	print "------------------------------------------------------------------"
	taken = tasks_assign(assets, map)

	# Set all the orders so the tasks are performed
	print "\nStep 3. Issuing orders to do tasks.."
	print "------------------------------------------------------------------"
	used_assets = []
	for task in taken:
		print task
		used_assets += task.issue()

	print
	print "Checks..."
	if len(assets) != len(used_assets):
		print "Some assets don't have tasks!"
		print " %i used assets, %s total assets" % (len(used_assets), len(assets))

		s1 = set([x.ref.id for x in assets])
		s2 = set([x.ref.id for x in used_assets])

		if len(s2) != len(used_assets):
			print "WARNING: For some reason issued orders twice to an object..."

		for id in s1.difference(s2):
			o = cache.objects[id]
			print '\t', repr(o),
			if FLEET_TYPE is o._subtype:
				for shipid, amount in o.ships:
					print (cache.designs[shipid].name, amount),
			print

import time
def persisence():
	connection, cache = connect()
	run(connection, cache)

	while True:
		connection.pump()

		pending = connection.buffered['frames-async']
		while len(pending) > 0:
			frame = pending.pop(0)
			if isinstance(frame, objects.TimeRemaining):
				if frame.time == 0:
					continue
				run(connection, cache)
		time.sleep(1)	

def main():
	run(*connect())

if __name__ == "__main__":
	import sys
	if len(sys.argv) > 1 and sys.argv[1] == '-p':
		sys.argv.pop(1)
		import hotshot
		prof = hotshot.Profile("hotshot_stats")
		prof.runcall(main)
		prof.close()
	if len(sys.argv) > 1 and sys.argv[1] == '-s':
		sys.argv.pop(1)
		main()
	else:
		persisence()

