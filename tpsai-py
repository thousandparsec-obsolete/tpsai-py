#! /usr/bin/python

from tp.netlib import Connection
from tp.netlib import failed, constants, objects
from tp.netlib.client import url2bits
from tp.client.cache import Cache

version = (0, 0, 1)

import copy
import math
import pprint

def dist(a, b):
	a = a.ref.pos
	b = b.ref.pos

	return math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2)

from things import *

# FIXME: These should be defined in a "profile" somewhere as they are all server specific...
PLANET_TYPE = 3
FLEET_TYPE  = 4

MOVE_ORDER     = 1
BUILD_ORDER    = 2
COLONISE_ORDER = 3

FRIGATE_SPEED    = 200000000
BATTLESHIP_SPEED = 300000000

FRIGATE_BUILD    = 2
BATTLESHIP_BUILD = 6

FRIGATE_POWER    = 0.2
BATTLESHIP_POWER = 1

MARGIN = 10

def tasks_cando(assets, tasks):
	"""\
	Figures out which tasks each asset can do.
	"""
	map = {}
	for asset in assets:
		map[asset] = []

		# Figure out which tasks we can do
		for task in tasks:
			if task.task == Task.BUILD:
				if not (BUILD_ORDER in asset.ref.order_types):
					continue

				soon    = 0
				portion = 100

				# How long is it going to take to "build" this task
				# FIXME: There should be a good way to abstract this...
				if task.ref.task == Task.COLONISE:
					soon += FRIGATE_BUILD
				if task.ref.task == Task.DESTROY:
					soon += BATTLESHIP_BUILD
				if task.ref.task == Task.TAKEOVER:
					soon += BATTLESHIP_BUILD + FRIGATE_BUILD

				# How long will it take for our built object to get to the target?
				if asset.ref.pos != task.ref.ref.ref.pos:
					# How soon we can finish this task is:
					#   build + distance/speed
					d = dist(asset, task.ref.ref) 
					if task.ref.task in (Task.COLONISE, Task.TAKEOVER):
						soon += d/FRIGATE_SPEED
					if task.ref.task == Task.DESTROY:
						soon += d/BATTLESHIP_SPEED
				
				# Work out the portion of this task we are actually going to build
				if task.ref.task in (Task.DESTROY, Task.TAKEOVER):
					portion = (task.ref.ref.power()+MARGIN)/BATTLESHIP_POWER

				map[asset].append((soon, task, portion))
				continue

			# Check we can go where needed for this task
			if hasattr(task.ref.ref, "pos") and asset.ref.pos != task.ref.ref.pos:
				if not MOVE_ORDER in asset.ref.order_types:
					continue

			if task.task in (Task.COLONISE, Task.TAKEOVER):
				# Only assets which have the colonise order are useful for these tasks
				if not (COLONISE_ORDER in asset.ref.order_types):
					continue

				if task.task == Task.COLONISE:
					soon = 0

					if asset.ref.pos != task.ref.ref.pos:
						# Ships always move at the slowest speed...
						soon += dist(asset, task.ref)/FRIGATE_SPEED

					map[asset].append((soon, task, 100))

			if task.task in (Task.DESTROY, Task.TAKEOVER):
				# FIXME: This won't work when we merge the Threats
				soon    = 0
				portion = (task.ref.power()+MARGIN) / asset.power()

				if asset.ref.pos != task.ref.ref.pos:
					soon = dist(asset, task.ref)/BATTLESHIP_SPEED

				map[asset].append((soon, task, portion))

	return map

def tasks_assign(assets, map):
	"""
	Assigns assets to each task.
	"""
	assets = copy.copy(assets)

	taken = set()
	while len(assets) > 0:
		asset = assets.pop(0)

		print
		print
		print "Assigning task for ", asset

		todo = copy.copy(map[asset])
		todo.sort()

		# The tasks we can complete soonest are first in the todo list now..
		while len(todo) > 0:
			soon, task, portion = todo.pop(0)

			# Can we complete this task sooner?
			if task.long() > soon:
				unassigned = task.assign(soon, asset, portion)
			
				print "Assigned to", task, "will complete in %s%% in %s turns" % (portion, soon)
				taken.add(task)

				# Reschedual assignment of assets which are now released...
				print "Took over from %r" % unassigned
				for soon, asset, portion in unassigned:
					assets.insert(0, asset)

				break
	
		# Nothing for me to do
		if len(todo) == 0:
			print "Nothing.."
			continue

	return list(taken)

def connect():
	debug = False

	import sys
	print sys.argv

	if len(sys.argv) > 1:
		uri = sys.argv.pop(1)
	else:
		uri = 'tp://tpsai-py:cannonfodder@localhost/'

	host, username, game, password = url2bits(uri)

	connection = Connection()

	# Download the entire universe
	if connection.setup(host=host, debug=False):
		print "Unable to connect to the host."
		return

	if failed(connection.connect("tpsai-py/%i.%i.%i" % version)):
		print "Unable to connect to the host."
		return

	if failed(connection.login(username, password)):
		# Try creating the user..
		print "User did not exist, trying to create user."
		if failed(connection.account(username, password, "", "tpsai-py bot")):
			print "Username / Password incorrect."
			return

		if failed(connection.login(username, password)):
			print "Created username, but still couldn't login :/"
			return

	cache = Cache(Cache.key(host, username))
	return connection, cache

def run(connection, cache):
	# Create the cache
	def callback(*args, **kw):
		#print args, kw
		pass

	cache.update(connection, callback)

	pid = cache.players[0].id
	print "My ID is ", pid

	neutrals = []
	assets = []
	threats = []

	# Classify each object as an Asset/Threat or Neutral and sort on the magnitude
	for object in cache.objects.values():
		if hasattr(object, 'owner'):
			if object.owner in (0, -1):
				neutrals.append(Neutral(object))
			elif object.owner == pid:
				assets.append(Asset(object))
			else:
				threats.append(Threat(object))

	# Now we need to collect all threats 
	#  - All threats in a single location are merge
	#  - All threats have a reenforment factor added (dependent on other threats)

	# Now create a list of tasks which need to be done.
	tasks = []
	
	# For each threat, we need to eliminate it or take it over
	for threat in threats:
		if PLANET_TYPE in threat._subtype:
			tasks.append(Task(Task.TAKEOVER, threat))
		else:
			tasks.append(Task(Task.DESTROY, threat))

	# For each neutral we want to colonise the planets
	for neutral in neutrals:
		if not neutral.ref._subtype is PLANET_TYPE:
			continue
		tasks.append(Task(Task.COLONISE, neutral))

	print "\nStep 1. Finding which assets can do the tasks.."
	print "------------------------------------------------------------------"
	map = tasks_cando(assets, tasks)

	print "\nStep 2. Assigning tasks to assets.."
	print "------------------------------------------------------------------"
	taken = tasks_assign(assets, map)

	# Now are there tasks we can do by building things
	print "\nStep 3. Figuring out what we should build.."
	print "------------------------------------------------------------------"

	for task in copy.copy(tasks):
		# Remove the task..
		tasks.remove(task)

		# This task is already satisified
		if task.long() < float('inf'):
			continue

		if task.task != Task.BUILD:
			# Build stuff for all tasks which can't be done already..
			tasks.append(Task(Task.BUILD, task))

	print "\nStep 4. Finding out which assets can do the tasks.."
	print "------------------------------------------------------------------"
	map = tasks_cando(assets, tasks)

	print "\nStep 5. Assigning assets.."
	print "------------------------------------------------------------------"
	taken += tasks_assign(assets, map)

	print 
	print
	# All tasks which can be done should be assigned now..	
	#pprint.pprint(tasks)

	# Set all the orders so the tasks are performed
	print "\nStep 6. Issuing orders to do tasks.."
	print "------------------------------------------------------------------"
	used_assets = []
	for task in taken:
		print task
		for soon, asset, portion in task.assigned:
			used_assets.append(asset)

			results = []

			# Issue the new order
			if task.task in (Task.COLONISE, Task.DESTROY, Task.TAKEOVER):
				desire = task.ref

				# Are we at the same location?
				if asset.ref.pos != desire.ref.pos:
					while True:
						pos = len(results)
						if asset.ref.order_number > pos:
							order = cache.orders[asset.ref.id][pos]

							# Remove the order if it isn't a move order
							if order.subtype != MOVE_ORDER:
								print "First order wasn't a move order!"
								connection.remove_orders(asset.ref.id, [pos])
								asset.ref.order_number -= 1
								continue

							# Remove the order if it isn't a move order to the correct location
							if order.pos != desire.ref.pos:
								print "First order was to wrong destination!"
								connection.remove_orders(asset.ref.id, [pos])
								asset.ref.order_number -= 1
								continue

							# Order is correct
							print "Object already had correct move order."
							results.append((True, 'Already existed...'))
							break
						else:
							print "Issuing new order to %s move %s" % (asset, desire.ref.pos)
							# We need to issue a move order instead.
							results.append(connection.insert_order(asset.ref.id, -1, MOVE_ORDER, desire.ref.pos))
							asset.ref.order_number += 1
							break

				# If it's a colonise order, we better colonise the thing
				if task.task in (Task.COLONISE, Task.TAKEOVER):
					while True:
						pos = len(results)
						if asset.ref.order_number > pos:
							order = cache.orders[asset.ref.id][pos]

							# Remove the order if it isn't a move order
							if order.subtype != COLONISE_ORDER:
								print "Object had wrong order type"
								connection.remove_orders(asset.ref.id, [pos])
								asset.ref.order_number -= 1
								continue

							# Order is correct
							print "Object already had correct colonise order."
							results.append((True, 'Already existed...'))
							break
						else:
							print "Issuing orders to %s colonise %r" % (asset, desire.ref)
							# We need to issue a move order instead.
							results.append(connection.insert_order(asset.ref.id, -1, COLONISE_ORDER)) #, desire.ref.id))
							asset.ref.order_number += 1
							break

			if task.task == Task.BUILD:
				# Remove current orders...
				connection.remove_orders(asset.ref.id, range(0, asset.ref.order_number))

				result = connection.insert_order(asset.ref.id, -1, BUILD_ORDER, [], [], 0, "")
				result = connection.get_orders(asset.ref.id, 0)
				ships = {}
				for id, name, max in result[0].ships[0]:
					ships[name] = id
				connection.remove_orders(asset.ref.id, [0]) 

				if task.ref.task == Task.COLONISE:
					# If we are referencing a colonise, better build a frigate
					print "Issuing orders to %s to build a frigate" % (asset,)
					results.append(connection.insert_order(asset.ref.id, -1, BUILD_ORDER, [], [(ships['Frigate'],1)], 0, "A robot army!"))
				if task.ref.task == Task.DESTROY:
					# Better build a battleship
					print "Issuing orders to %s to build a battleship" % (asset,)
					results.append(connection.insert_order(asset.ref.id, -1, BUILD_ORDER, [], [(ships['Battleship'],1)], 0, "A robot army!"))
				if task.ref.task == Task.TAKEOVER:
					# Better build a battleship and a frigate
					print "Issuing orders to %s to build a battleship and frigate" % (asset,)
					results.append(connection.insert_order(asset.ref.id, -1, BUILD_ORDER, [], [(ships['Frigate'],1), (ships['Battleship'],1)], 0, "A robot army!"))
				
			if len(results) == 0:
				print
				continue

			for i, result in enumerate(results):
				if not result[0]:
					raise IOError("Wasn't able to issue an order for some reason! %s" % repr(result))

				# Order should complete in
				result = connection.get_orders(asset.ref.id, 0)
				if not result[0]:
					raise IOError("Wasn't able to issue an order for some reason! %s" % repr(result))
				print "Order %i will complete in %s turns" % (i, result[0].turns)
			print

	print
	print "Checks..."
	if len(assets) != len(used_assets):
		print "Some assets don't have tasks!"
		print " %i used assets, %s total assets" % (len(used_assets), len(assets))

		s1 = set([x.ref.id for x in assets])
		s2 = set([x.ref.id for x in used_assets])

		if len(s2) != len(used_assets):
			print "WARNING: For some reason issued orders twice to an object..."

		for id in s1.difference(s2):
			o = cache.objects[id]
			print '\t', repr(o),
			if FLEET_TYPE is o._subtype:
				for shipid, amount in o.ships:
					print (cache.designs[shipid].name, amount),
			print

import time
def persisence():
	connection, cache = connect()
	run(connection, cache)

	while True:
		connection.pump()

		pending = connection.buffered['frames-async']
		while len(pending) > 0:
			frame = pending.pop(0)
			if isinstance(frame, objects.TimeRemaining):
				if frame.time == 0:
					continue
				run(connection, cache)
		time.sleep(1)	

def main():
	run(*connect())

if __name__ == "__main__":
	import sys
	if len(sys.argv) > 1 and sys.argv[1] == '-p':
		sys.argv.pop(1)
		import hotshot
		prof = hotshot.Profile("hotshot_stats")
		prof.runcall(main)
		prof.close()
	if len(sys.argv) > 1 and sys.argv[1] == '-s':
		sys.argv.pop(1)
		main()
	else:
		persisence()

